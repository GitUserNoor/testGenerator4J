/*  * This program is licensed under Common Public License Version 0.5. * * For License Information and conditions of use, see "LICENSE" in packaged *  */package org.jtestcase;import java.io.FileNotFoundException;import java.util.Hashtable;import java.util.Iterator;import java.util.Locale;import java.util.StringTokenizer;import java.util.Vector;import org.jtestcase.core.asserter.Asserter;import org.jtestcase.core.digester.DigesterException;import org.jtestcase.core.digester.JTestCaseDigester;import org.jtestcase.core.digester.XQueryException;import org.jtestcase.core.mapping.HashMapper;import org.jtestcase.core.model.ParamGroupInstance;import org.jtestcase.core.model.ParamInstance;import org.jtestcase.core.type.ComplexTypeConverter;import org.jtestcase.core.type.TypeConversionException;/** * This utility class is used for unit test to help reading data (test cases) * from xml file. *  * @author <a href="mailto:faustothegrey@sourceforge.net">Fausto Lelli</a> * @author <a href="mailto:yuqingwang_99@yahoo.com">Yuqing Wang</a> * @author <a href="mailto:ckoelle@sourceforge.net">Christian Koelle</a> *  *  * $Id: JTestCase.java,v 1.14 2005/10/19 19:11:29 faustothegrey Exp $ */public class JTestCase {	/**	 * The digester used for parsing the XML	 */	private JTestCaseDigester digester;	/**	 * Type convert facility. This class is used to map "string" representation	 * of type to contrete instances of the type represented	 */	private ComplexTypeConverter typeConverter;	/**	 * Mapper to return the parameters defined in the model tree as HashMap	 * values	 * 	 */	private HashMapper hashMapper;	/**	 * Assert facility	 */	private Asserter asserter;	/**	 * The class name which is used to find the class tag in XML	 */	private String mClassName = null;	public Asserter getAsserter() {		return asserter;	}	public void setAsserter(Asserter asserter) {		this.asserter = asserter;	}	public HashMapper getMapper() {		return hashMapper;	}	public void setMapper(HashMapper mapper) {		this.hashMapper = mapper;	}	public JTestCaseDigester getDigester() {		return digester;	}	protected void setDigester(JTestCaseDigester digester) {		this.digester = digester;	}	public ComplexTypeConverter getTypeConverter() {		return typeConverter;	}	protected void setTypeConverter(ComplexTypeConverter typeConverter) {		this.typeConverter = typeConverter;	}	public String getMClassName() {		return mClassName;	}	protected void setMClassName(String className) {		mClassName = className;	}	/***************************************************************************	 * 	 * API METHODS	 * 	 * 	 **************************************************************************/	/**	 * Constructed from full file name and class name. This class name is	 * specifed in data file under "/tests/class@name". It's recommended that	 * its value equals to the real testing class's name. <br/>	 * 	 * 	 * JTestCase looks for data files in following orders: 1) looks from	 * filesystem path. For example, if you specified XML file as	 * "/aa/bb/my-data.xml", then JTestCase will look for /aa/bb/my-data.xml	 * from your filesystem directory. <br/> 2) if JTestCase fails above search,	 * it then looks from $CLASSPATH based directories. For example, if you have	 * classpathroot/myclass/my-data.xml in your CLASSPATH, you can retrieve the	 * XML file using "myclass/my-date.xml". 3) If fails again, JTestCase will	 * then throw FileNotFoundException exception. <br/> (Note: providing	 * filesystem path will improve the performance).	 * 	 * 	 * @param fileName -	 *            name of data file. Will be searched by absolute path first. If	 *            not found, then will be searched based on classpath.	 * @param className -	 *            name of test program. Is defined in data file in	 *            /tests/class@name	 * @throws JTestCaseException	 *             Problem with reading the file, validating the XML or with the	 *             XML structure	 * @throws FileNotFoundException	 *             Thrown if the fileName (xml data file) in not found	 */	public JTestCase(String fileName, String className)			throws JTestCaseException, FileNotFoundException {		mClassName = className;		try {			digester = new JTestCaseDigester(fileName, this);		} catch (XQueryException e) {			throw new JTestCaseException(e);		}		typeConverter = new ComplexTypeConverter();		if (this.getGlobalParamLocale() != null) {			typeConverter.setLocale(this.getGlobalParamLocale());		}		hashMapper = new HashMapper(digester, typeConverter);		asserter = new Asserter(digester, typeConverter);	}	/**	 * Retrieves all control parameters. Control parameters are parameters that	 * are defined for the whole JTestCase data set. They are valid for all	 * class-tags in the file.	 * 	 * @return A hashtable with the control parameters. Key is defined in	 *         /tests/params/param@name, value is param's object value with type	 *         as indicated in /test/class/params/param@type. If "type" is not	 *         specified in data file, then "String" is default type.	 * @throws FileNotFoundException	 *             in case the file in not found	 * @throws JTestCaseException	 *             in case of any other error	 */	public Hashtable getControlParams() throws JTestCaseException,			FileNotFoundException {		Hashtable paramValues = new Hashtable();		try {			Iterator paramInstances = digester.getTestCaseControlParams()					.iterator();			while (paramInstances.hasNext()) {				ParamInstance paramInstance = (ParamInstance) paramInstances						.next();				Object value;				try {					value = typeConverter._convertType(paramInstance);				} catch (InstantiationException e) {					// TODO Auto-generated catch block					throw new JTestCaseException(e);				} catch (IllegalAccessException e) {					// TODO Auto-generated catch block					throw new JTestCaseException(e);				}				paramValues.put(paramInstance.getName(), value);			}			Iterator paramGroupInstances = digester					.getTestCaseControlParamGroups().iterator();			while (paramGroupInstances.hasNext()) {				ParamGroupInstance paramGroupInstance = (ParamGroupInstance) paramGroupInstances						.next();				_getParamValuesFromGroupInstance(paramGroupInstance.getName(),						paramValues, paramGroupInstance);			}		} catch (TypeConversionException tce) {			throw new JTestCaseException(					"Error converting param to Java type. " + "\n   "							+ tce.getMessage());		} catch (DigesterException e) {			throw new JTestCaseException("Error retrieving params." + "\n   "					+ e.getMessage());		}		return paramValues;	}	/**	 * Retrieves all global (class-wide) params into Hashtable. HashKey is	 * param's name, HashValue is param's value. These params are common to all	 * tested methods for the specified tested class, and should be retrieved in	 * testing class's constructor.	 * 	 * @return Hashtable. Key is param's name defined in	 *         /tests/class/params/param@name, value is param's Object value	 *         with type as indicated in /test/class/params/param@type. If not	 *         "type" specified in data file, then "String" is default type.	 * @throws JTestCaseException	 *             if an internal error occurs	 * @throws FileNotFoundException	 * @throws IllegalAccessException	 * @throws InstantiationException	 */	public Hashtable getGlobalParams() throws JTestCaseException,			FileNotFoundException, InstantiationException,			IllegalAccessException {		Hashtable paramValues = new Hashtable();		try {			Iterator paramInstances = digester.getTestCaseGlobalParams(					this.getClassUnderTest()).iterator();			while (paramInstances.hasNext()) {				ParamInstance paramInstance = (ParamInstance) paramInstances						.next();				Object value = typeConverter._convertType(paramInstance);				paramValues.put(paramInstance.getName(), value);			}			Iterator paramGroupInstances = digester					.getTestCaseGlobalParamGroups(this.getClassUnderTest())					.iterator();			while (paramGroupInstances.hasNext()) {				ParamGroupInstance paramGroupInstance = (ParamGroupInstance) paramGroupInstances						.next();				_getParamValuesFromGroupInstance(paramGroupInstance.getName(),						paramValues, paramGroupInstance);			}		} catch (TypeConversionException tce) {			throw new JTestCaseException("Error converting param to Java type");		} catch (DigesterException e) {			throw new JTestCaseException("Error retrieving params.");		}		return paramValues;	}	/**	 * Helps setting the Locale for DateFormats	 * 	 * @return the Locale as specified in the global Parameter named 'locale'	 * @throws JTestCaseException	 * @throws FileNotFoundException	 */	public Locale getGlobalParamLocale() throws JTestCaseException,			FileNotFoundException {		Hashtable globalParams;		try {			globalParams = this.getGlobalParams();		} catch (InstantiationException e) {			// TODO Auto-generated catch block			throw new JTestCaseException(e);		} catch (IllegalAccessException e) {			// TODO Auto-generated catch block			throw new JTestCaseException(e);		}		String localeString = (String) globalParams.get("locale");		if (localeString != null) {			StringTokenizer tokenizer = new StringTokenizer(localeString, "_");			String language = "";			String country = "";			if (!tokenizer.hasMoreElements()) {				throw new JTestCaseException(						"locale string is not correctly formatted");			}			language = tokenizer.nextToken();			if (!tokenizer.hasMoreElements()) {				return new Locale(language);			} else {				country = tokenizer.nextToken();				return new Locale(language, country);			}		} else {			return null;		}	}	/**	 * Retrieves types of all global (class-wided) params into Hashtable.	 * HashKey is param's name, HashValue is param's type in String which	 * represents java class's name. These params are common to all tested	 * methods for the specified tested class, and should be retrieved in	 * testing class's constructor.	 * 	 * @return Hashtable. Key is param's name defined in	 *         /tests/class/params/param@name, value is param's Object value	 *         with type as indecated in /test/class/params/param@type. If not	 *         "type" specified in data file, then "String" is default type.	 * @throws JTestCaseException	 *             if an internal error occurs	 * @throws FileNotFoundException	 *             public Hashtable getGlobalParamTypes() throws	 *             JTestCaseException, FileNotFoundException { Hashtable	 *             paramValues = new Hashtable(); try { Iterator paramInstances =	 *             digester.getTestCaseGlobalParams(	 *             this.getClassUnderTest()).iterator(); while	 *             (paramInstances.hasNext()) { ParamInstance paramInstance =	 *             (ParamInstance) paramInstances .next();	 *             paramValues.put(paramInstance.getName(), paramInstance	 *             .getType()); } } catch (DigesterException e) { throw new	 *             JTestCaseException("Error retrieving params."); } return	 *             paramValues; }	 */	/**	 * Get number of test cases for a given method. This method name is	 * specified in data file in /tests/class/method@name. It's recommended that	 * its value equals to the real testing method's name.	 * 	 * @param methodName -	 *            name of tested method. Defined in data file in	 *            /tests/class/method@name.	 * @return int. Number of test cases that are defined for this method in	 *         data file.	 * @throws JTestCaseException	 *             if an internal error occurs	 */	public int getCountOfTestCasesInMethod(String methodName)			throws JTestCaseException {		try {			return digester.getTestCasesPerMethod(methodName).size();		} catch (DigesterException e) {			throw new JTestCaseException("Error retrieving test cases.");		}	}	/**	 * Get all test cases' name for a given method into Vector. This method	 * requires that for a given method, each test case should be named	 * uniquely.	 * 	 * @param methodName -	 *            name of tested method. Defined in data file in	 *            /tests/class/method@test-case.	 * @return Vector of names of test cases that are defined for this method in	 *         data file in /tests/class/method@test-case.	 * @throws JTestCaseException	 *             if an internal error occurs	 */	public Vector getTestCasesInstancesInMethod(String methodName)			throws JTestCaseException {		Vector testcases;		try {			testcases = digester.getTestCasesPerMethod(methodName);		} catch (DigesterException e) {			throw new JTestCaseException(e.getMessage());		}		return testcases;	}	/**	 * Returns the class name used to find the class tags in XML	 * 	 * @return the class name	 */	public String getClassUnderTest() {		return mClassName;	}	/***************************************************************************	 * 	 * NOT-API METHODS	 * 	 * @throws FileNotFoundException	 * 	 * 	 **************************************************************************/	/**	 * Extracts the assert types from a AssertGroupInstance	 * 	 * @param path	 *            the path so far	 * @param flatAsserts	 *            the hashtable with the asserts	 * @param assertGroupInstance	 *            the AssertGroupInstance object to be analysed	 * @throws JTestCaseException	 *             if an internal error occurs	 * 	 * private void _getAssertParamTypesFromGroupInstance(String path,	 * MultiKeyHashtable flatAsserts, AssertParamGroupInstance	 * assertParamGroupInstance) throws JTestCaseException { Iterator assertIter =	 * assertParamGroupInstance.getAssertParamInstances() .iterator(); while	 * (assertIter.hasNext()) { AssertParamInstance asert =	 * (AssertParamInstance) assertIter.next(); String[] key = new String[2];	 * key[0] = path + "/" + asert.getName(); key[1] = asert.getAction();	 * flatAsserts.put(key, asert.getType()); } Iterator assertParamGroupIter =	 * assertParamGroupInstance .getAssertParamGroupInstances().iterator();	 * while (assertParamGroupIter.hasNext()) { AssertParamGroupInstance	 * assertGroup = (AssertParamGroupInstance) assertParamGroupIter .next();	 * _getAssertParamTypesFromGroupInstance( path + "/" +	 * assertGroup.getName(), flatAsserts, assertGroup); } }	 */	/**	 * Extracts the assert types from a AssertGroupInstance	 * 	 * @param path	 *            the path so far	 * @param flatAsserts	 *            the hashtable with the asserts	 * @param assertGroupInstance	 *            the AssertGroupInstance object to be analysed	 * @throws JTestCaseException	 *             if an internal error occurs private void	 *             _getAssertParamTypesFromGroupInstance(String path,	 *             MultiKeyHashtable flatAsserts, AssertParamGroupInstance	 *             assertParamGroupInstance) throws JTestCaseException {	 *             Iterator assertIter = assertParamGroupInstance	 *             .getAssertParamInstances().iterator(); while	 *             (assertIter.hasNext()) { AssertParamInstance asert =	 *             (AssertParamInstance) assertIter.next(); String[] key = new	 *             String[2]; key[0] = path + "/" + asert.getName(); key[1] =	 *             asert.getAction(); flatAsserts.put(key, asert.getType()); }	 *             Iterator assertParamGroupIter = assertParamGroupInstance	 *             .getAssertParamGroupInstances().iterator(); while	 *             (assertParamGroupIter.hasNext()) { AssertParamGroupInstance	 *             assertGroup = (AssertParamGroupInstance) assertParamGroupIter	 *             .next(); _getAssertParamTypesFromGroupInstance(path + "/" +	 *             assertGroup.getName(), flatAsserts, assertGroup); } }	 * 	 */	/**	 * Extracts the param values from a ParamGroupInstance	 * 	 * @param path	 *            the path so far	 * @param flatParams	 *            the hashtable with the params	 * @param paramGroupInstance	 *            the ParamGroupInstance object to be analysed	 * @throws JTestCaseException	 *             if an internal error occurs	 */	protected void _getParamValuesFromGroupInstance(String path,			Hashtable flatParams, ParamGroupInstance paramGroupInstance)			throws JTestCaseException {		Iterator paramIter = paramGroupInstance.getParamInstances().iterator();		try {			while (paramIter.hasNext()) {				ParamInstance param = (ParamInstance) paramIter.next();				Object value;				try {					value = typeConverter._convertType(param);				} catch (InstantiationException e) {					// TODO Auto-generated catch block					throw new JTestCaseException(e);				} catch (IllegalAccessException e) {					// TODO Auto-generated catch block					throw new JTestCaseException(e);				}				flatParams.put(path + "/" + param.getName(), value);			}			Iterator paramGroupIter = paramGroupInstance					.getParamGroupInstances().iterator();			while (paramGroupIter.hasNext()) {				ParamGroupInstance paramGroup = (ParamGroupInstance) paramGroupIter						.next();				_getParamValuesFromGroupInstance(path + "/"						+ paramGroup.getName(), flatParams, paramGroup);			}		} catch (TypeConversionException tce) {			throw new JTestCaseException("Error converting param to Java type");		}	}}